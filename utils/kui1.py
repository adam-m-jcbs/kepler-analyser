#!/usr/bin/env python
# generated by wxGlade 0.6.2 on Thu Jan 31 16:31:06 2008

import wx
import  wx.lib.newevent
import matplotlib
matplotlib.use('WXAgg')
from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.backends.backend_wxagg import NavigationToolbar2WxAgg
from matplotlib.figure import Figure
import sys, os, time
from threading import Thread
from ConfigParser import ConfigParser
import numpy as n

import bec_utils, kepler

import pdb

# begin wxGlade: extracode
# end wxGlade

#creating new Event classes and binder functions
(AnimationRedrawEvent, EVT_ANIMATION_REDRAW) = wx.lib.newevent.NewEvent()
(ModelCacheLoadedEvent, EVT_MODELCACHE_LOADED) = wx.lib.newevent.NewEvent()

class AxisProperty:
    """Class to contain a property which can be used on one axis in a plot"""
    def __init__(self, key, label, log=True):
        """
        key: a string with the name of a property of a Model instance.
        label: a string to be used as Axis label.
        log: wether this Axis should be drawn logarithmically.
        """
        self.key = key
        self.label = label
        self.log = log
    
    def get_keys(self):
        """
        Return an array of keys from a string representation
        in self.key.
        Example: "one,two, three  " -> ['one', 'two', 'three']
        """
        keys = self.key.split(',')
        keys = [k.strip() for k in keys]
        
        return keys
        
    def get_data(self, model):
        """
        Return the data from the model that corresponds to the keys of this
        object.
        """
        #return [model.get(key) for key in self.get_keys()]
        return [eval(key, model) for key in self.get_keys()]
    
    def get_series(self, models, gridpoint=0):
        """
        Return the data from the array of models by taking the data per
        model at a given gridpoint.
        """
        return [n.array([model.get(key)[gridpoint] for model in models]) for key in self.get_keys()]
        
    def get_range_linear(self, models):
        """
        Calculate and return the largest interval in which all values
        lie for all models for linear plot scale.
        """
        # get initial range
        data = self.get_data(models[0])
        ymin = min([min(d) for d in data])
        ymax = max([max(d) for d in data])
        
        # iterate over rest
        for m in models[1:]:
            data = self.get_data(m)
            ymin = min(ymin, min([min(d) for d in data]))
            ymax = max(ymax, max([max(d) for d in data]))
        
        return (ymin, ymax)
    
    def get_range_log(self, models):
        """Calculate and return the largest interval in which all values
        lie for all models for log plot scale."""
        # get initial range. NB: not really correct, can be done better!!
        data = self.get_data(models[0])[0]
        nonzero = data[data>0]
        if len(nonzero):
            ymin = min(nonzero)
            ymax = max(nonzero)
        else:
            ymin = 1e-30
            ymax = 1e30
        
        # iterate over rest
        for m in models:
            data = self.get_data(m)
            for d in data:
                if len(n.where(d>0)[0])>0:
                    Ymin = min(d[d>0])
                else:
                    Ymin = 1e-30
                
                ymin = min(ymin, Ymin)                
                ymax = max(ymax, max(d))
        
        return (ymin, ymax)
    
    def get_range(self, models):
        """Calculate and return the largest interval in which all values
        lie for all models"""
        if self.log:
            return self.get_range_log(models)
        else:
            return self.get_range_linear(models)

class SingleTimeProperty(AxisProperty):
    """
    An AxisProperty that describes plotting a quantity (a scalar, not an array)
    versus time (or model number).
    """
    
    def get_range_linear(self, models):
        """Calculate and return the largest interval in which all values
        lie for all models for linear plot scale."""
        data = self.get_series(models)
        ymin = min([min(d) for d in data])
        ymax = max([max(d) for d in data])
        return (ymin, ymax)
    
    def get_range_log(self, models):
        """Calculate and return the largest interval in which all values
        lie for all models for log plot scale."""
        data = self.get_series(models)
        try:
            ymin = min([min(d) for d in data])
        except:
            ymin = 1e-30
        ymax = max([max(d) for d in data])
        return (ymin, ymax)
    
    def get_series(self, models, gridpoint=0):
        """Return the data from the array of models that corresponds to the key of this
        object. Note that the gridpoint argument is not used here."""
        return [n.array([model.get(key) for model in models]) for key in self.get_keys()]

class ReducedModelCache:
    """Caches ReducedModel instances. This class really handles the limiting
    of memory usage by creating ReducedModels and has (at the moment) little
    to do with ModelCache, although in the future a combined approach could be taken."""

    class LoadThread(Thread):
        """Load Models in a thread to make the gui responsive,
        even if not all models are loaded yet."""
        
        def __init__(self, cache, step=1):
            """Hook this loader up to a ReducedModelCache."""
            Thread.__init__(self)
            self.cache = cache
            self.cont = True
            self.step = step
        
        def run(self):
            cache = self.cache
            cache.models = []
            for i in range(cache.min, cache.max+1, self.step):
                print i
                if not self.cont:
                    return
                cache.models += [cache.load_model(i)]
            if i<cache.max:
                i = cache.max
                print i
                cache.models += [cache.load_model(i)]
            evt = ModelCacheLoadedEvent()
            wx.PostEvent(cache.frame, evt)
    
    def __init__(self, binfile, frame, min=0, max=-1, properties=[], step=1, reduced=True):
        """
        binfile: BinFile object from which the models are read
        frame: wx event handler
        min: first model to be read (default 0)
        max: last model to be read (default -1, i.e. end of file)
        properties: properties to load from Models into ReducedModels
        reduced: indicate if we reduce memory usage.
        """
        self.binfile = binfile
        self.frame = frame
        self.loader = None
        self.step = step
        self.reduced = reduced

        self.models=[]
        self.set_properties(properties)
    
    def set_properties(self, properties):
        """Set the properties and load ReducedModels."""
        self.properties = properties
        if self.reduced or len(self.models)==0:
            self.load_models()
        else:
            evt = ModelCacheLoadedEvent()
            wx.PostEvent(self.frame, evt)

    def load_models(self, min=0, max=-1):
        """Load range of ReducedModels from binfile."""
        if max == -1:
            max = len(self.binfile.index) - 1
        self.min = min
        self.max = max
        
        if self.loader:
            self.loader.cont = False
            while self.loader.isAlive():
                time.sleep(0.0001) #wait for previous LoadThread to go away
        loader = self.LoadThread(self, step=self.step)
        self.loader = loader
        loader.start()
    
    def load_model(self, number):
        """Load a ReducedModel from model *number* in binfile"""
        reduced = self.binfile.read_a_model(number)
        # Reduce the model. Cannot be done if we use eval on properties.
        if self.reduced:
            reduced = bec_utils.ReducedModel(reduced, self.properties)
        return reduced

    def has_model(self, number):
        """
        Return boolean whether model number is available.
        """
        if len(self.models)>number-self.min:
            return True
        return False
    
    def get_model(self, number):
        """return requested Model"""
        while 1:
            try:
                return self.models[number-self.min]
            except:
                time.sleep(0.01) # Wait for model to load
    
    def get_models(self):
        m = self.get_model(self.max) # Wait for all models to be loaded.
        return self.models

    def get_len(self):
        """
        Return the amount of models contained in this cache.
        """
        return self.max - self.min + 1

class ModelView:
    """An abstraction of all that is part of plotting a series of models in one
    view (Figure)."""

    class AnimationLoop(Thread):
        """A Thread to control the animation of current plot."""

        def __init__(self, modelview, speed = 0.05):
            """Bind to a ModelView. Animate at given speed (higher is slower)"""
            Thread.__init__(self)
            self.modelview = modelview
            self.speed = speed

        def run(self):
            modelview = self.modelview
            frame = modelview.frame
            speed = self.speed
            while modelview.animate:
                next = modelview.current_model + 1
                if next > modelview.get_max_model():
                    next = 0
                evt = AnimationRedrawEvent(model=next)
                wx.PostEvent(frame, evt)
                time.sleep(speed)
    
    def __init__(self, modelcache, xaxis, yaxis, frame):
        """
        models: array of Model instances
        xaxis_properties,
        yaxis_properties: dictionary of label (string): AxisProperty
        frame: the frame in which this ModelView is shown
        """
        
        # initialize properties
        self.modelcache = modelcache
        self.current_model = modelcache.min #first model to be shown
        self.current_xaxis = xaxis #default axis.
        self.current_yaxis = yaxis
        self.animate = False
        self.zerotime = 0.0

        # color map for convection
        self.convection_alpha = 1
        self.convection_colors = {' ': (0,0,0,0), #transparent
                                  'C': (0,0.5,0,self.convection_alpha),#green
                                  'O': (0,0.75,0.75,self.convection_alpha), #cyan
                                  'R': (0.75, 0.75, 0,self.convection_alpha), #yellow
                                  'S': (1,0,0,self.convection_alpha), #red
                                  'T': (0,0,1,self.convection_alpha), #blue
                                  'W': (0.75, 0, 0.75,self.convection_alpha)} #magenta
        
        # initialize Figure
        self.frame = frame
        self.figure = Figure(figsize=(5,4), dpi=100)
        self.axes = self.figure.add_subplot(111)
        self.canvas = FigureCanvas(frame, -1, self.figure)
        self.background = self.canvas.copy_from_bbox(self.axes.bbox)
        
        # initialize Lines
        self.lines = []
        xdata = self.get_xdata()
        for y,l in zip(self.get_ydata(), self.get_ylabels()):
            print len(xdata), len(y)
            self.lines.append(self.axes.plot(xdata, y, '+-', label=l)[0])
        self.set_max_xlim()
        self.set_max_ylim()
        self.draw_xlog()
        self.draw_ylog()
        self.time_text = self.axes.text(0.5, 0.9, str(self.get_time()),
                                        transform = self.axes.transAxes)
        self.legend = self.axes.legend()
        self.draw_all()

        # bind events
        self.frame.Bind(EVT_ANIMATION_REDRAW, self.animation_redraw)
        self.frame.Bind(EVT_MODELCACHE_LOADED, self.models_loaded)
    
    def draw(self):
        """redraw line only"""
        # restore the clean slate background
        self.canvas.restore_region(self.background)
        # just draw the animated artist
        for line in self.lines:
            self.axes.draw_artist(line)
        self.axes.draw_artist(self.time_text)
        # just redraw the axes rectangle
        self.canvas.blit(self.axes.bbox)
    
    def draw_all(self):
        """redraw everything: line, ticks, labels, etc."""
        self.stop_animation() #safer to stop animation
        self.axes.set_xlabel(self.get_xlabel())
        self.axes.set_ylabel(self.get_ylabel())

        # get a new background
        for line in self.lines:
            line.set_visible(False)
        self.time_text.set_visible(False)
        self.canvas.draw()
        self.background = self.canvas.copy_from_bbox(self.axes.bbox)
        for line in self.lines:
            line.set_visible(True)
        self.time_text.set_visible(True)
        self.canvas.draw()

    def clear(self):
        """Clear the plot, e.g. before resizing the frame"""
        # restore the clean slate background
        self.canvas.restore_region(self.background)

    def set_max_xlim(self):
        """Zoom X-axis to maximum range necessary to plot all
        X values for all models."""
        self.axes.set_xlim(self.current_xaxis.get_range(self.modelcache.models))
    
    def set_max_ylim(self):
        """Zoom Y-axis to maximum range necessary to plot all
        Y values for all models."""
	r = self.current_yaxis.get_range(self.modelcache.models)
	if r[0]<r[1]:
        	self.axes.set_ylim(r)
    
    def get_xlabel(self):
        """return the label of the x-axis"""
        return self.current_xaxis.label
    
    def get_ylabel(self):
        """return the label of the y-axis"""
        return self.current_yaxis.label

    def get_ylabels(self):
        """
        Return short labels for the y-axis, to be used in the legend.
        """
        return self.current_yaxis.get_keys()

    def get_max_model(self):
        """Return the index of the last model, i.e. number of models - 1."""
        return self.modelcache.get_len()-1
    
    def get_canvas(self):
        """Return canvas"""
        return self.canvas

    def set_xaxis(self, xaxis):
        """Change the current X-axis. xaxis should be an index for the
        xaxis_properties array."""
        self.current_xaxis = xaxis
        self.update_cache() # Inform the Cache that we need different data.
        xdata = self.get_xdata()
        for line,ydata in  zip(self.lines, self.get_ydata()):
            line.set_data(xdata, ydata)
        self.set_max_xlim()
        self.draw_xlog()
        self.draw_all()

    def set_yaxis(self, yaxis):
        """Change the current Y-axis. yaxis should be an index for the
        yaxis_properties array."""
        # Remove old lines
        for line in self.lines:
            self.axes.lines.remove(line)
        # Reset color cycle
        self.axes._get_lines.count = 0
        # Create new lines
        self.current_yaxis = yaxis
        self.update_cache()
        self.lines = []
        for y,l in zip(self.get_ydata(), self.get_ylabels()):
            self.lines.append(self.axes.plot(self.get_xdata(), y, '+-', label=l)[0])
        self.set_max_ylim()
        self.draw_ylog()
        # self.legend.remove()
        self.legend = self.axes.legend()
        self.draw_all()

    def set_xlog(self, log=True):
        """Set the X-axis logarithmic"""
        self.current_xaxis.log = log
        self.draw_xlog()
        self.set_max_xlim()
        self.set_max_ylim()
        self.draw_all()

    def set_ylog(self, log=True):
        """Set the X-axis logarithmic"""
        self.current_yaxis.log = log
        self.draw_ylog()
        self.set_max_xlim()
        self.set_max_ylim()
        self.draw_all()

    def draw_xlog(self):
        """Instruct the figure to draw X-axis logarithmically.
        Please use set_xlog"""
        log = self.current_xaxis.log
        if log:
            self.axes.set_xscale('log')
        else:
            self.axes.set_xscale('linear')

    def draw_ylog(self):
        """Instruct the figure to draw Y-axis logarithmically.
        Please use set_ylog"""
        log = self.current_yaxis.log
        if log:
            self.axes.set_yscale('log')
        else:
            self.axes.set_yscale('linear')

    def get_xdata(self):
        """Return the data for the X-axis"""
        if isinstance(self.current_xaxis, SingleTimeProperty):
            return self.current_xaxis.get_series(self.modelcache.get_models(), 0)[0]
        else:
            return self.current_xaxis.get_data(self.modelcache.get_model(self.current_model))[0]

    def get_ydata(self):
        """Return the data for the Y-axis"""
        if isinstance(self.current_xaxis, SingleTimeProperty):
            return self.current_yaxis.get_series(self.modelcache.get_models(), -3)
        else:
            return self.current_yaxis.get_data(self.modelcache.get_model(self.current_model))

    def get_time(self):
        """Return the time of the current model minus the time of the first model."""
        return self.modelcache.get_model(self.current_model).time - self.zerotime

    def timezero(self, time=None):
        """
        The displayed time is time - zerotime. This routine sets zerotime
        to the time, or, if empty, the time of the current model.
        """
        if time!=None:
            self.zerotime = time
        else:
            self.zerotime = self.modelcache.get_model(self.current_model).time
        self.time_text.set_text("Time: %e s"%self.get_time())
        self.draw()
    
    def set_model(self, model):
        """Set the current model and update the plot accordingly."""
        if not self.modelcache.has_model(model):
            return False# Model not yet loaded
        self.current_model = model
        xdata = self.get_xdata()
        for line,ydata in  zip(self.lines, self.get_ydata()):
            line.set_data(xdata, ydata)
        self.time_text.set_text("Time: %e s"%self.get_time())
        self.draw()
        return True

    def update_cache(self):
        """Let the cache know which data we need"""
        properties = ['time', 'dtime']
        properties += [self.current_xaxis.key]
        properties += self.current_yaxis.get_keys()
        self.modelcache.set_properties(properties)

    #Event handlers:

    def animation_redraw(self, evt):
        """Update figure for animation"""
        self.set_model(evt.model)
        #call for gui update
        self.frame.animation_redraw(evt)

    def models_loaded(self, evt):
        """Update figure since all models are loaded"""
        self.set_max_xlim()
        self.set_max_ylim()

    #Animation routines:

    def start_animation(self):
        """Start animation"""
        if not self.animate:
            self.animate = True
            self.AnimationLoop(self).start()

    def stop_animation(self):
        """Stop animation"""
        self.animate = False

    def toggle_animation(self):
        """Switch animation on/off"""
        if self.animate:
            self.stop_animation()
        else:
            self.start_animation()

class MyFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # Load configuration
        self.step = 1
        self.load_config()
        
        # begin wxGlade: MyFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)

        #create AxisProperty array
        self.create_axes_properties()

        #create a matplotlib figure:
        if len(sys.argv)>1:
            filename = sys.argv[1]
        else:
            filename = '/data/laurensk/binary/rudy/he_accretion1/wd1.bin1'
        if len(sys.argv)>3:
            self.load_model(filename, int(sys.argv[2]), int(sys.argv[3]))
        else:
            self.load_model(filename)

        self.canvas = self.modelview.get_canvas()
        self.window_1 = self.canvas
        wx.EVT_PAINT(self, self.OnPaint)

        #toolbar
        self.toolbar = NavigationToolbar2WxAgg(self.canvas)
        self.toolbar.Realize()
        self.SetToolBar(self.toolbar)
        self.toolbar.update()
        
        # Menu Bar
        self.frame_1_menubar = wx.MenuBar()
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(0, "&Open\tCtrl+O", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.Append(6, "&Copy Figure\tCtrl+C", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(5, "Print Setup", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.Append(4, "Print Preview", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.Append(3, "&Print\tCtrl+P", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(1, "&Quit\tCtrl+Q", "", wx.ITEM_NORMAL)
        self.frame_1_menubar.Append(wxglade_tmp_menu, "File")
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(7, "Zero &Time\tCtrl+T", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.Append(8, "Reset Time\tShift+Ctrl+T", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.Append(9, "&Refresh\tCtrl+R", "", wx.ITEM_NORMAL)
        self.frame_1_menubar.Append(wxglade_tmp_menu, "View")
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(2, "About", "", wx.ITEM_NORMAL)
        self.frame_1_menubar.Append(wxglade_tmp_menu, "Help")
        self.SetMenuBar(self.frame_1_menubar)
        # Menu Bar end
        self.window_1 = self.canvas #FigureCanvas(self, -1)
        self.label_1 = wx.StaticText(self, -1, "X-axis")
        self.checkbox_logx = wx.CheckBox(self, -1, "Log")
        self.choice_xaxis = wx.Choice(self, -1, choices=self.xaxis_properties[0])
        self.label_2 = wx.StaticText(self, -1, "Y-axis")
        self.checkbox_logy = wx.CheckBox(self, -1, "Log")
        self.radio_btn_1 = wx.RadioButton(self, -1, "Structure")
        self.choice_yaxis_copy = wx.Choice(self, -1, choices=self.structure_properties[0])
        self.radio_btn_1_copy = wx.RadioButton(self, -1, "Rotation")
        self.choice_yaxis_copy_1 = wx.Choice(self, -1, choices=self.rotation_properties[0])
        self.radio_btn_1_copy_1 = wx.RadioButton(self, -1, "Magnetic Field")
        self.choice_yaxis_copy_2 = wx.Choice(self, -1, choices=self.magnetic_properties[0])
        self.radio_btn_1_copy_2 = wx.RadioButton(self, -1, "Abundances")
        self.choice_yaxis_copy_3 = wx.Choice(self, -1, choices=self.abundance_properties[0])
        self.text_ctrl = wx.ComboBox(self, -1, "", wx.DefaultPosition, wx.DefaultSize, [], wx.TE_PROCESS_ENTER)
        self.radio_btn_1_copy_3 = wx.RadioButton(self, -1, "Custom")
        self.button_play = wx.Button(self, -1, "Play")
        self.button_stop = wx.Button(self, -1, "Stop")
        self.spin_ctrl_1 = wx.SpinCtrl(self, -1, "", min=0, max=100)
        self.slider_1 = wx.Slider(self, -1, 0, 0, 10, style=wx.SL_HORIZONTAL|wx.SL_AUTOTICKS)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.OnOpen, id=0)
        self.Bind(wx.EVT_MENU, self.OnCopy, id=6)
        self.Bind(wx.EVT_MENU, self.OnPrintSetup, id=5)
        self.Bind(wx.EVT_MENU, self.OnPrintPreview, id=4)
        self.Bind(wx.EVT_MENU, self.OnPrint, id=3)
        self.Bind(wx.EVT_MENU, self.OnExit, id=1)
        self.Bind(wx.EVT_MENU, self.OnAbout, id=2)
        self.Bind(wx.EVT_MENU, self.OnTimeZero, id=7)
        self.Bind(wx.EVT_MENU, self.OnResetTime, id=8)
        self.Bind(wx.EVT_MENU, self.OnRefresh, id=9)
        self.Bind(wx.EVT_CHECKBOX, self.OnLogX, self.checkbox_logx)
        self.Bind(wx.EVT_CHOICE, self.OnXaxisSelected, self.choice_xaxis)
        self.Bind(wx.EVT_CHECKBOX, self.OnLogY, self.checkbox_logy)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnStructureSelected, self.radio_btn_1)
        self.Bind(wx.EVT_CHOICE, self.OnStructureSelected, self.choice_yaxis_copy)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnRotationSelected, self.radio_btn_1_copy)
        self.Bind(wx.EVT_CHOICE, self.OnRotationSelected, self.choice_yaxis_copy_1)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnMagneticSelected, self.radio_btn_1_copy_1)
        self.Bind(wx.EVT_CHOICE, self.OnMagneticSelected, self.choice_yaxis_copy_2)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnAbundancesSelected, self.radio_btn_1_copy_2)
        self.Bind(wx.EVT_CHOICE, self.OnAbundancesSelected, self.choice_yaxis_copy_3)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnCustomSelected, self.radio_btn_1_copy_3)
        self.Bind(wx.EVT_TEXT_ENTER, self.OnCustomSelected, self.text_ctrl)
        self.Bind(wx.EVT_COMBOBOX, self.OnCustomSelected, self.text_ctrl)
        self.Bind(wx.EVT_BUTTON, self.OnPlay, self.button_play)
        self.Bind(wx.EVT_BUTTON, self.OnStop, self.button_stop)
        self.Bind(wx.EVT_SPINCTRL, self.OnSpin, self.spin_ctrl_1)
        self.Bind(wx.EVT_COMMAND_SCROLL, self.scroll, self.slider_1)
        # end wxGlade

        self.Bind(wx.EVT_SIZE, self.OnResize)
        self.Bind(wx.EVT_CLOSE, self.OnExit)
        self.Fit()

        #set scrollbar and slider
        maxmodel = self.modelcache.get_len()-1
        self.slider_1.SetMax(maxmodel)
        self.spin_ctrl_1.SetRange(0, maxmodel)
        self.current = 0

        # Apply settings from configuration.
        xaxis = self.choice_xaxis.GetSelection()
        self.modelview.set_xaxis(self.xaxis_properties[1][xaxis])
        yaxis = self.choice_yaxis_copy.GetSelection()
        self.modelview.set_yaxis(self.structure_properties[1][yaxis])
        self.modelview.set_xlog(self.checkbox_logx.GetValue())
        self.modelview.set_ylog(self.checkbox_logy.GetValue())
        self.SetDimensions(int(self.get_config('window', 'x', 0)),
                           int(self.get_config('window', 'y', 0)),
                           int(self.get_config('window', 'width', 500)),
                           int(self.get_config('window', 'height', 500)),
                           -1)

    def __set_properties(self):
        # begin wxGlade: MyFrame.__set_properties
        self.SetTitle("BEC Model Viewer")
        self.choice_xaxis.SetToolTipString("X-axis property")
        self.choice_xaxis.SetSelection(0)
        self.choice_yaxis_copy.SetToolTipString("Y-axis property")
        self.choice_yaxis_copy.SetSelection(19)
        self.choice_yaxis_copy_1.SetToolTipString("Y-axis property")
        self.choice_yaxis_copy_1.SetSelection(0)
        self.choice_yaxis_copy_2.SetToolTipString("Y-axis property")
        self.choice_yaxis_copy_2.SetSelection(0)
        self.choice_yaxis_copy_3.SetToolTipString("Y-axis property")
        self.choice_yaxis_copy_3.SetSelection(0)
        self.text_ctrl.SetToolTipString("Enter or select Y-axis property")
        self.button_play.SetToolTipString("Play/Pause animation")
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: MyFrame.__do_layout
        grid_sizer_1 = wx.FlexGridSizer(3, 1, 0, 0)
        grid_sizer_3 = wx.FlexGridSizer(1, 4, 0, 0)
        grid_sizer_4 = wx.FlexGridSizer(1, 2, 10, 10)
        grid_sizer_5 = wx.FlexGridSizer(8, 2, 0, 0)
        grid_sizer_2 = wx.FlexGridSizer(1, 4, 0, 0)
        #grid_sizer_2.Add(self.button_1, 0, 0, 0)
        grid_sizer_1.Add(grid_sizer_2, 1, wx.EXPAND, 0)
        grid_sizer_4.Add(self.window_1, 1, wx.EXPAND, 0)
        grid_sizer_5.Add(self.label_1, 0, 0, 0)
        grid_sizer_5.Add(self.checkbox_logx, 0, 0, 0)
        grid_sizer_5.Add((20, 20), 0, 0, 0)
        grid_sizer_5.Add(self.choice_xaxis, 0, 0, 0)
        grid_sizer_5.Add(self.label_2, 0, 0, 0)
        grid_sizer_5.Add(self.checkbox_logy, 0, 0, 0)
        grid_sizer_5.Add(self.radio_btn_1, 0, 0, 0)
        grid_sizer_5.Add(self.choice_yaxis_copy, 0, 0, 0)
        grid_sizer_5.Add(self.radio_btn_1_copy, 0, 0, 0)
        grid_sizer_5.Add(self.choice_yaxis_copy_1, 0, 0, 0)
        grid_sizer_5.Add(self.radio_btn_1_copy_1, 0, 0, 0)
        grid_sizer_5.Add(self.choice_yaxis_copy_2, 0, 0, 0)
        grid_sizer_5.Add(self.radio_btn_1_copy_2, 0, 0, 0)
        grid_sizer_5.Add(self.choice_yaxis_copy_3, 0, 0, 0)
        grid_sizer_5.Add(self.radio_btn_1_copy_3, 0, 0, 0)
        grid_sizer_5.Add(self.text_ctrl, 0, 0, 0)
        grid_sizer_4.Add(grid_sizer_5, 1, wx.ADJUST_MINSIZE, 0)
        grid_sizer_1.Add(grid_sizer_4, 1, wx.EXPAND, 0)
        grid_sizer_3.Add(self.button_play, 0, 0, 0)
        grid_sizer_3.Add(self.button_stop, 0, 0, 0)
        grid_sizer_3.Add(self.spin_ctrl_1, 0, 0, 0)
        grid_sizer_3.Add(self.slider_1, 0, wx.EXPAND, 0)
        grid_sizer_3.AddGrowableCol(3)
        grid_sizer_1.Add(grid_sizer_3, 1, wx.EXPAND, 0)
        grid_sizer_4.AddGrowableRow(0)
        grid_sizer_4.AddGrowableCol(0)
        self.SetSizer(grid_sizer_1)
        grid_sizer_1.Fit(self)
        grid_sizer_1.AddGrowableRow(1)
        grid_sizer_1.AddGrowableCol(0)
        self.Layout()
        # end wxGlade
    
    def create_axes_properties(self):
        """Create arrays of AxisProperty instances."""
        #X-axis
        self.xaxis_properties = {'Grid points':AxisProperty('gridpoints', 'Grid points', log=False),
                                 'Mass':AxisProperty('xm', 'Mass (Msun)', log=False),
                                 'Radius':AxisProperty('r', 'Radius (cm)', log=False),
                                 'Column depth': AxisProperty('y', 'Column Depth (g/cm2)'),
                                 'Time': SingleTimeProperty('time', 'Time (s)', log=False),
                                 'Model number': SingleTimeProperty('model', 'Model number', log=False)}
        #Y-axis
        self.structure_properties = {'Radial Velocity':AxisProperty('u', 'Radial velocity (cm/s)'),
                                     '-Radial Velocity':AxisProperty('minu', '- Radial velocity (cm/s)'),
                                     'Change in radius':AxisProperty('dr', 'dr (cm)'),
                                     'Mass Density':AxisProperty('ro', 'Mass density (g/cm^3)'),
                                     'Temperature':AxisProperty('t', 'Temperature (K)'),
                                     'Luminosity':AxisProperty('sl', 'Luminosity (erg/s)'),
                                     'Specific Thermal Energy':AxisProperty('e', 'Specific Thermal Energy (erg/g)'),
                                     'Opacity':AxisProperty('cap', 'Opacity (cm^2/g)'),
                                     'Optical depth':AxisProperty('tau', 'Optical depth'),
                                     'Mass':AxisProperty('xm', 'Mass (Msun)'),
                                     'Convection':AxisProperty('convection', 'Convection'),
                                     'Convective diffusion':AxisProperty('diff', 'Convective diffusion'),
                                     'Shell mass':AxisProperty('dm', 'dm (g)'),
                                     'Ideal gas Pressure':AxisProperty('pg', 'Pg (dyne)'),
                                     'Radiation Pressure':AxisProperty('pr', 'Pr (dyne)'),
                                     'Electron Degeneracy':AxisProperty('edegen', 'Electrons degenerate if <1'),
                                     #'Degeneracy':AxisProperty('degen', 'Matter degenerate if <1'),
                                     'Energy Dissipation Rate':AxisProperty('ediss', 'Energy Dissipation Rate (erg/g/s)'),
                                     'Thermal Timescale': AxisProperty('t_thermal', 'Thermal timescale (s)'),
                                     'Energy Generation Rate': AxisProperty('enucl', 'Nuclear energy generation rate (erg/s/g)'),
                                     'Column depth': AxisProperty('y', 'Column Depth (g/cm2)'),
                                     'Sound speed': AxisProperty('cs', 'Sound speed for ideal gas (cm/s)')
                                     }
        
        self.abundance_properties = {}
        for name in bec_utils.isotope_names():
            i = name[0].upper() + name[1:]
            self.abundance_properties[i] = AxisProperty(name, i)
        
        self.rotation_properties = {'Angular Momentum':AxisProperty('al', 'Angular Momentum'),
                                    'Angular Velocity':AxisProperty('w', 'Angular Velocity (rad/s)'),
                                    'Moment of Inertia':AxisProperty('ai', 'Moment of Inertia'),
                                    'Xdif':AxisProperty('xdif', 'xdif (cm^2/s)'),
                                    'Summed diffusion coef.':AxisProperty('dg', 'dg (cm^2/s)'),
                                    'Timescale dg':AxisProperty('t_dg', 'Timescale dg (s)'),
                                    'Dynamic Shear':AxisProperty('d1', 'd1 (cm^2/s)'),
                                    'Solberg-Hoiland':AxisProperty('d2', 'd2 (cm^2/s)'),
                                    'Secular Shear':AxisProperty('d3', 'd3 (cm^2/s)'),
                                    'Goldreich-Schubert-Fricke':AxisProperty('d5', 'd5 (cm^2/s)'),
                                    'Eddington-Sweet':AxisProperty('d4', 'd4 (cm^2/s)'),
                                    'Specific Angular Momentum':AxisProperty('alspec', 'Specific Angular Momentum')}
        
        self.magnetic_properties = {'bfvisc':AxisProperty('bfvisc', 'bfvisc (cm2/s)'),
                                    'bfdiff':AxisProperty('bfdiff', 'bfdiff (cm2/s)'),
                                    'Timescale bfvisc':AxisProperty('t_bfvisc', 'Timescale bfvisc (s)'),
                                    'Timescale bfdiff':AxisProperty('t_bfdiff', 'Timescale bfdiff (s)'),
                                    'bfbr':AxisProperty('bfbr', 'B_r (Gauss)'),
                                    'bfbt':AxisProperty('bfbt', 'B_phi (Gauss)'),
                                    'bfq':AxisProperty('bfq', 'Shear'),
                                    'ibflag':AxisProperty('ibflag', 'ibflag'),
                                    'Chemical gradient':AxisProperty('bfq0', 'q0'),
                                    'Thermal buoyancy':AxisProperty('bfq1', 'q1')}

        self.custom_properties = {}
        
        # Sort alphabetically.
        keys = self.xaxis_properties.keys()
        keys.sort()
        self.xaxis_properties = (keys, [self.xaxis_properties[i] for i in keys])
        
        keys = self.structure_properties.keys()
        keys.sort()
        self.structure_properties = (keys, [self.structure_properties[i] for i in keys])
        
        keys = self.abundance_properties.keys()
        keys = [name[0].upper() + name[1:] for name in bec_utils.isotope_names()]
        self.abundance_properties = (keys, [self.abundance_properties[i] for i in keys])
        
        keys = self.rotation_properties.keys()
        keys.sort()
        self.rotation_properties = (keys, [self.rotation_properties[i] for i in keys])
        
        keys = self.magnetic_properties.keys()
        keys.sort()
        self.magnetic_properties = (keys, [self.magnetic_properties[i] for i in keys])
    
    def load_config(self, filename='.becviewer'):
        """
        Load config file.
        """
        self.config_filename = os.path.expanduser("~") + '/' + filename
        self.config = ConfigParser()
        self.config.read(self.config_filename)
    
    def save_config(self):
        """
        Save configuration to file.
        """
        self.set_config('view', 'x-axis', self.choice_xaxis.GetSelection())
        self.set_config('view', 'y-axis', self.choice_yaxis_copy.GetSelection())
        self.set_config('view', 'x-log', self.checkbox_logx.GetValue())
        self.set_config('view', 'y-log', self.checkbox_logy.GetValue())
        
        self.set_config('window', 'width', self.GetSize().Get()[0])
        self.set_config('window', 'height', self.GetSize().Get()[1])
        self.set_config('window', 'x', self.GetPositionTuple()[0])
        self.set_config('window', 'y', self.GetPositionTuple()[1])
        
        self.config.write(open(self.config_filename, 'w'))
    
    def get_config(self, section, key, default):
        """
        Return the config variable from section if available, otherwise
        default.
        """
        try:
            return self.config.get(section, key)
        except Exception, e:
            return default
    
    def get_config_bool(self, section, key, default):
        """
        Return the boolean config variable from section if available, otherwise
        default.
        """
        try:
            return self.config.getboolean(section, key)
        except Exception, e:
            return default
    
    def set_config(self, section, key, value):
        """
        Set a config variable to value in given section.
        """
        config = self.config
        if not config.has_section(section):
            config.add_section(section)
        config.set(section, key, value)

    def scroll(self, event): # wxGlade: MyFrame.<event_handler>
        self.current = self.slider_1.GetValue()
        self.current = self.current/self.step*self.step
        self.show_model(self.current)
        event.Skip()

    def OnPaint(self, event):
        self.modelview.draw()
        event.Skip()

    def OnResize(self, event):
        """Called when window is resized."""
        #clear the plot
        self.modelview.clear()
        # redo layout
        self.Layout()
        # replot
        self.modelview.draw_all()

    def OnTimeZero(self, event):
        """
        Called to set a new zero point for the time.
        """
        self.modelview.timezero()

    def OnResetTime(self, event):
        """
        Called to reset the zero point for the time.
        """
        self.modelview.timezero(0)

    def load_model(self, filename, min=0, max=-1):
        """load model from file, either all or from min to max."""
        b = kepler.DumpFiles(filename)
        self.modelcache = ReducedModelCache(b, self, min, max, ['t', 'y', 'time'], step=self.step, reduced=True)
        self.modelview = ModelView(self.modelcache, self.xaxis_properties[1][0],
                                   dict(zip(*self.structure_properties))['Temperature'], self)

    def OnRefresh(self, event):
        """
        Reload the BinFile. This may be done e.g. if the bin file has been updated.
        """
        self.modelcache.binfile.update_index()
        self.modelcache.load_models()
        
        maxmodel = self.modelcache.get_len()-1
        self.slider_1.SetMax(maxmodel)
        self.spin_ctrl_1.SetRange(0, maxmodel)

    def show_model(self, number):
        """plot model with given number"""

        #Only update gui when we are not showing animation.
        #See also animation_redraw.
        #if not self.modelview.animate:
        #set the gui to this number
        self.slider_1.SetValue(number)
        self.spin_ctrl_1.SetValue(number)

        self.modelview.set_model(number)
        self.current = number

    def replot_line(self):
        """Replot this frame's line"""
        # restore the clean slate background
        self.canvas.restore_region(self.background)
        # just draw the animated artist
        self.axes.draw_artist(self.line)
        # just redraw the axes rectangle
        self.canvas.draw()#blit(self.axes.bbox)

    def OnOpen(self, event): # wxGlade: MyFrame.<event_handler>
        print "Event handler `OnOpen' not implemented!"
        event.Skip()

    def OnCopy(self, event):
        self.canvas.Copy_to_Clipboard(event=event)

    def OnPrint(self, event): # wxGlade: MyFrame.<event_handler>
        self.canvas.Printer_Init()
        self.canvas.Printer_Print(event=event)

    def OnPrintPreview(self, event):
        self.canvas.Printer_Preview(event=event)

    def OnPrintSetup(self, event):
        self.canvas.Printer_Setup2(event=event)

    def OnExit(self, event): # wxGlade: MyFrame.<event_handler>
        self.save_config()
        sys.exit()

    def OnAbout(self, event): # wxGlade: MyFrame.<event_handler>
        info = wx.AboutDialogInfo()
        info.SetDevelopers(['Laurens Keek'])
        info.SetCopyright('(c) 2006-2008 Laurens Keek')
        info.SetDescription('An interactive viewer for model files generated by the binary evolution code (BEC).')
        info.SetName('BEC Model Viewer')
        info.SetVersion('1.01')
        
        wx.AboutBox(info)

    def OnXaxisSelected(self, event): # wxGlade: MyFrame.<event_handler>
        xaxis = self.choice_xaxis.GetSelection()
        xaxis = self.xaxis_properties[1][xaxis]
        self.modelview.set_xaxis(xaxis)
        self.checkbox_logx.SetValue(xaxis.log)

    def OnLogX(self, event): # wxGlade: MyFrame.<event_handler>
        self.modelview.set_xlog(self.checkbox_logx.GetValue())
        event.Skip()

    def OnLogY(self, event): # wxGlade: MyFrame.<event_handler>
        self.modelview.set_ylog(self.checkbox_logy.GetValue())
        event.Skip()
    
    def OnPlay(self, event): # wxGlade: MyFrame.<event_handler>
        self.modelview.toggle_animation()
        event.Skip()
    
    def OnStop(self, event): # wxGlade: MyFrame.<event_handler>
        self.modelview.stop_animation()
        event.Skip()
    
    def OnSpin(self, event): # wxGlade: MyFrame.<event_handler>
        self.current = self.spin_ctrl_1.GetValue()
        self.show_model(self.current)
        event.Skip()
    
    def animation_redraw(self, evt):
        """Update gui for animation"""
        current_model = evt.model
        self.slider_1.SetValue(current_model)
        self.spin_ctrl_1.SetValue(current_model)
    
    def OnStructureSelected(self, event): # wxGlade: MyFrame.<event_handler>
        self.radio_btn_1.SetValue(1)
        yaxis = self.choice_yaxis_copy.GetSelection()
        yaxis = self.structure_properties[1][yaxis]
        self.modelview.set_yaxis(yaxis)
        self.checkbox_logy.SetValue(yaxis.log)
    
    def OnRotationSelected(self, event): # wxGlade: MyFrame.<event_handler>
        self.radio_btn_1_copy.SetValue(1)
        yaxis = self.choice_yaxis_copy_1.GetSelection()
        yaxis = self.rotation_properties[1][yaxis]
        self.modelview.set_yaxis(yaxis)
        self.checkbox_logy.SetValue(yaxis.log)
    
    def OnMagneticSelected(self, event): # wxGlade: MyFrame.<event_handler>
        self.radio_btn_1_copy_1.SetValue(1)
        yaxis = self.choice_yaxis_copy_2.GetSelection()
        yaxis = self.magnetic_properties[1][yaxis]
        self.modelview.set_yaxis(yaxis)
        self.checkbox_logy.SetValue(yaxis.log)
    
    def OnAbundancesSelected(self, event): # wxGlade: MyFrame.<event_handler>
        self.radio_btn_1_copy_2.SetValue(1)
        yaxis = self.choice_yaxis_copy_3.GetSelection()
        yaxis = self.abundance_properties[1][yaxis]
        self.modelview.set_yaxis(yaxis)
        self.checkbox_logy.SetValue(yaxis.log)
    
    def OnCustomSelected(self, event): # wxGlade: MyFrame.<event_handler>
        self.radio_btn_1_copy_3.SetValue(1)
        yaxis = self.choice_yaxis_copy_3.GetSelection()
        selected =  str(self.text_ctrl.GetValue()) # Need casting to convert unicode to normal string.
        if selected not in self.custom_properties:
            yaxis = AxisProperty(selected, selected)
            self.custom_properties[selected] = yaxis
            self.text_ctrl.Append(selected)
        else:
            yaxis = self.custom_properties[selected]
        
        self.modelview.set_yaxis(yaxis)
        self.checkbox_logy.SetValue(yaxis.log)

# end of class MyFrame


if __name__ == "__main__":
    app = wx.PySimpleApp(0)
    wx.InitAllImageHandlers()
    frame_1 = MyFrame(None, -1, "")
    app.SetTopWindow(frame_1)
    frame_1.Show()
    app.MainLoop()
